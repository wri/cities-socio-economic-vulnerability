library(shiny)
library(tidyr)
library(tidyverse)
library(dplyr)
library(readr)
library(vroom)
library(data.table)
library(leaflet)
library(leaflet.extras)
library(sf)
library(httr)
library(jsonlite)
library(geojsonsf)
library(glue)
library(shinyFeedback)
library(shinycssloaders)
library(shinyjs)

# read census variables definition
census_variables_definition = read.csv(
  "https://cities-socio-economic-vulnerability.s3.eu-west-3.amazonaws.com/mexico/census/census_variables_definition.csv",
  fileEncoding = "UTF-8-BOM"
)

census_variables_group = unique(census_variables_definition$variable_category)

# Read census variables from API
mx_fields <-
  "https://data-api.globalforestwatch.org/dataset/wri_mexico_municipality_socio_economic_vulnerability/v2020.2/fields"
fields_res <- GET(mx_fields)
variable_names <-
  fromJSON(content(fields_res, as = "text", encoding = "UTF-8"))$data$field_name
not_census <-
  c(
    "gfw_fid",
    "cvegeo",
    "cve_ent",
    "cve_mun",
    "nomgeo",
    "cvempo",
    "cve_sun",
    "sun_label",
    "tipo_cd",
    "year",
    "entity_level",
    "municipality_id",
    "state_name",
    "municipality_name",
    "locality_id",
    "locality_name",
    "ageb_id",
    "block_id",
    "geom",
    "geom_wm",
    "gfw_area__ha",
    "gfw_geostore_id",
    "gfw_geojson",
    "gfw_bbox",
    "created_on",
    "updated_on"
  )
variable_names <- variable_names[!variable_names %in% not_census]

# Define UI for application
ui <- tagList(
  useShinyjs(),
  navbarPage(
    "Census Dashboard",
    # Mexico Tab ----
    tabPanel(
      "Mexico",
      useShinyFeedback(),
      
      fluidRow(
        # select entity level
        column(
          3,
          selectizeInput(
            "entity_level",
            "Geographic Level:",
            choices = c("State", "Municipality", "Locality", "AGEB", "Block")
          )
        ),
        
        # select group of variable
        column(
          3,
          selectizeInput(
            inputId = "variable_group",
            label = "Census variable theme:",
            choices = census_variables_group,
            selected = census_variables_group[1],
            multiple = FALSE
          )
        ),
        
        # select variable
        column(
          3,
          selectizeInput(
            inputId = "variable",
            label = "Census variable:",
            #choices = NULL,
            choices = variable_names,
            multiple = FALSE
          )
        ),
        
        # select year
        column(
          3,
          selectizeInput(
            inputId = "year",
            label = "Year:",
            choices = 2020,
            selected = 2020,
            multiple = FALSE
          )
        ),
        
        # select state
        column(
          4,
          selectizeInput(
            inputId = "state_name",
            label = "State:",
            choices = c("All"),
            selected = "All",
            multiple = FALSE
          )
        ),
        
        
        column(
          4,
          selectizeInput(
            inputId = "municipality_name",
            label = "Municpality:",
            choices =  NULL,
            multiple = FALSE
          )
        ),
        
        column(
          4,
          selectizeInput(
            inputId = "locality_name",
            label = "Locality:",
            choices = NULL,
            multiple = FALSE
          )
        )
        
      ),
      
      # Create a new row for the table.
      # DT::dataTableOutput("table"),
      column(
        6,
        withSpinner(DT::dataTableOutput("table")),
        downloadButton(outputId = "downloadData",
                       label = "Download Tabular data")
      ),
      column(
        6,
        withSpinner(leafletOutput("census_map",
                                  height = 600)),
        downloadButton(outputId = "downloadGeoData",
                       label = "Download Geospatial data")
      )
      
    ),
    # Brazil Tab ----
    tabPanel("Brazil"),
    # Colombia Tab ----
    tabPanel("Colombia"),
    # India Tab ----
    tabPanel("India")
  )
)



# Define server
server <- function(input, output, session) {
  # Query MX State API
  state_data <- reactive({
    mx_state_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_state_socio_economic_vulnerability/v2020/query"
    select_clause <-
      paste0("SELECT state_name, gfw_geojson, ",
             input$variable,
             " FROM result",
             collapse = "")
    select_query <- list(sql = select_clause)
    res <-
      GET(mx_state_query, query = select_query)
    res_content <-
      fromJSON(content(res, as = "text", encoding = "UTF-8"))$data
    bind_rows(res_content)
  })
  
  # Query MX Municipality API
  muni_data <- reactive({
    mx_muni_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_municipality_socio_economic_vulnerability/v2020.2/query"
    select_clause <-
      paste0(
        "SELECT state_name, municipality_name, gfw_geojson, ",
        input$variable,
        " FROM result",
        collapse = ""
      )
    select_query <- list(sql = select_clause)
    res_muni <- GET(mx_muni_query , query = select_query)
    res_content <-
      fromJSON(content(res_muni, as = "text", encoding = "UTF-8"))$data
    bind_rows(res_content)
  })
  
  # Query MX Locality API
  locality_data <- reactive({
    mx_locality_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_locality_socio_economic_vulnerability/v2020.2/query"
    select_clause <-
      paste0(
        "SELECT state_name, locality_name, gfw_geojson, ",
        input$variable,
        " FROM result",
        collapse = ""
      )
    select_query <- list(sql = select_clause)
    resp <- GET(mx_locality_query , query = select_query)
    resp_content <-
      fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
    bind_rows(resp_content)
  })
  
  # Query AGEB API
  ageb_data <- reactive({
    mx_ageb_api <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_ageb_socio_economic_vulnerability/v2020.2/query"
    
    select_clause <-
      paste0(
        "SELECT gfw_fid, ageb_id, state_name, municipality_name, locality_name, gfw_geojson, ",
        input$variable,
        " FROM result",
        collapse = ""
      )
    # Construct WHERE {state_name} AND {municipality_name}"
    if (input$municipality_name != "All") {
      second_entity <-  "municipality_name"
      second_value <- input$municipality_name
    } else if (input$locality_name != "All") {
      second_entity <-  "locality_name"
      second_value <- input$locality_name
    }
    where_query <-
      paste(
        select_clause,
        glue(
          "WHERE state_name = '{input$state_name}' AND {second_entity} = '{second_value}' LIMIT 1000"
        )
      )
    
    # OFFSET query
    offset_query <- function(query, offset) {
      paste(query,
            glue("OFFSET {offset}"))
    }
    
    offset <- 0
    
    initial_query <- list(sql = where_query)
    count_query <- list(sql)
    # GET Query
    resp <- GET(mx_ageb_api, query = initial_query)
    if (http_error(resp)) {
      print("Query error")
    }
    resp_content <-
      fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
    payload <- resp_content
    
    while (length(resp_content) > 0) {
      offset <- offset + 1000
      next_page <- list(sql = offset_query(where_query, offset))
      resp <- GET(mx_ageb_api, query = next_page)
      if (http_error(resp)) {
        print("Query error")
        break
      }
      resp_content <-
        fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
      payload = (rbind(payload, resp_content))
    }
    
    
    bind_rows(payload)
  }) %>% bindCache(input$state_name, input$municipality_name, input$locality_name)
  
  # Query MX Block API
  block_data <- reactive({
    # Query construction
    mx_block_api <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_block_socio_economic_vulnerability/v2020.1/query"
    
    # Determine if municipality or locality is used
    if (input$municipality_name != "All") {
      second_entity <-  "municipality_name"
      second_value <- input$municipality_name
    } else if (input$locality_name != "All") {
      second_entity <-  "locality_name"
      second_value <- input$locality_name
    }
    
    count_clause <-
      paste(
        "SELECT COUNT(gfw_fid) FROM result",
        glue(
          "WHERE state_name = '{input$state_name}' AND {second_entity} = '{second_value}' LIMIT 1000"
        )
      )
    count_query <- list(sql = count_clause)
    resp <- GET(mx_block_api, query = count_query)
    if (http_error(resp)) {
      print("Query error")
    }
    resp_content <-
      fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
    block_count <- resp_content
    
    select_clause <-
      paste0(
        "SELECT gfw_fid, block_id, state_name, municipality_name, locality_name, gfw_geojson, ",
        input$variable,
        " FROM result",
        collapse = ""
      )

    
    # Construct WHERE {state_name} AND {municipality_name}"
    where_query <-
      paste(
        select_clause,
        glue(
          "WHERE state_name = '{input$state_name}' AND {second_entity} = '{second_value}' LIMIT 1000"
        )
      )
    
    # OFFSET query
    offset_query <- function(query, offset) {
      paste(query,
            glue("OFFSET {offset}"))
    }
    
    offset <- 0
    
    initial_query <- list(sql = where_query)
    count_query <- list(sql)
    # GET Query
    withProgress(message = "Query loading", {
      resp <- GET(mx_block_api, query = initial_query)
      if (http_error(resp)) {
        print("Query error")
      }
      resp_content <-
        fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
      payload <- resp_content
      
      while (length(resp_content) > 0) {
        incProgress(1000)
        offset <- offset + 1000
        page_notice <-
          paste("Getting blocks through ", offset, "of", block_count)
        #showNotification(page_notice)
        next_page <- list(sql = offset_query(where_query, offset))
        resp <- GET(mx_block_api, query = next_page)
        if (http_error(resp)) {
          print("Query error")
          break
        }
        resp_content <-
          fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
        payload = (rbind(payload, resp_content))
      }
    })
    
    bind_rows(payload)
  }) %>% bindCache(input$state_name, input$municipality_name, input$locality_name)
  
  observe({
    # Populate initial state names and census variables
    mx_state_names <- unique(state_data()$state_name)
    updateSelectizeInput(session, "state_name", choices = c("All", mx_state_names))
  })
  
  # Toggle input fields based on selection
  observeEvent(input$entity_level, {
    switch(
      input$entity_level,
      "State" = {
        hide("municipality_name")
        hide("locality_name")
      },
      "Municipality" = {
        show("municipality_name")
        hide("locality_name")
      },
      "Locality" = {
        show("locality_name")
        hide("municipality_name")
      },
      "AGEB" = {
        show("municipality_name")
        show("locality_name")
      },
      "Block" = {
        show("municipality_name")
        show("locality_name")
      }
    )
  })
  
  # Load data table based on census variable input
  observeEvent({input$entity_level
    input$variable  
    input$state_name
    input$municipality_name
    input$locality_name}, {
      
      # render data table
      render_table <- reactive({
        data_filtered_table = data_filtered %>%
          as.data.frame()
        
        output$table <- DT::renderDataTable(DT::datatable(
          data_filtered_table,
          filter = 'top',
          options = list(
            paging = TRUE,
            pageLength = 10,
            scrollX = TRUE,
            scrollY = TRUE,
            autoWidth = TRUE,
            server = FALSE
          )
        ))
        
        # output data to download ----
        output$downloadData <- downloadHandler(
          filename = function() {
            paste("data-", Sys.Date(), ".csv", sep = "")
          },
          content = function(file) {
            write.csv(data_filtered_table, file)
          }
        )
      })
      
      # filter data for data table
      switch(input$entity_level,
             "State" = {
               if (input$state_name == "All") {
                 data_filtered = state_data() %>%
                   select("state_name", input$variable)
               } else {
                 data_filtered = state_data() %>%
                   filter(state_name == input$state_name) %>%
                   select("state_name", input$variable)
               }
             }, 
             "Municipality" = {
               if (input$state_name == "All") {
                 data_filtered = muni_data() %>%
                   select("state_name",
                          "municipality_name", 
                          input$variable)
               }  else if (input$municipality_name == "All") {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name) %>%
                   select(state_name,
                          municipality_name,
                          input$variable)
               }
               else {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name,
                          municipality_name == input$municipality_name) %>%
                   select("state_name",
                          "municipality_name",
                          input$variable)
               }
             }, 
             "Locality" = {
               if (input$state_name == "All") {
                 data_filtered = locality_data() %>%
                   select("state_name",
                          "locality_name", 
                          input$variable)
               }  else if (input$locality_name == "All") {
                 data_filtered = locality_data() %>%
                   filter(state_name == input$state_name) %>%
                   select(state_name,
                          locality_name,
                          input$variable)
               }
               else {
                 data_filtered = locality_data() %>%
                   filter(state_name == input$state_name,
                          locality_name == input$locality_name) %>%
                   select("state_name",
                          "locality_name",
                          input$variable)
               }
             },
             "AGEB" = {
               state_not_all <- input$state_name != "All"
               feedbackWarning("state_name",!state_not_all, "Please select a state")
               muni_not_all <- input$municipality_name != "All"
               feedbackWarning("municipality_name", !muni_not_all, "Please select a Municipality OR Locality")
               locality_not_all <- input$locality_name != "All"
               feedbackWarning("locality_name", !locality_not_all, "Please select a Locality OR Municipality")
               if (req(input$state_name != "All" && input$locality_name != "All")) {
                 data_filtered = ageb_data() %>%
                   select("locality_name", "ageb_id", input$variable)
               } else {data_filtered = ageb_data() %>%
                 select("municipality_name", "ageb_id", input$variable)}
               
             },
             "Block" = {
               state_not_all <- input$state_name != "All"
               feedbackWarning("state_name",!state_not_all, "Please select a state")
               muni_not_all <- input$municipality_name != "All"
               feedbackWarning("municipality_name", !muni_not_all, "Please select a Municipality OR Locality")
               req(input$state_name != "All" && input$municipality_name != "All")
               locality_not_all <- input$locality_name != "All"
               feedbackWarning("locality_name", !locality_not_all, "Please select a Locality OR Municipality")
               req(input$state_name != "All" && input$locality_name != "All")
               if (req(input$state_name != "All" && input$locality_name != "All")) {
                 data_filtered = block_data() %>%
                   select("locality_name", "block_id", input$variable)
               } else {data_filtered = block_data() %>%
                 select("municipality_name", "block_id", input$variable)}
             }
      )
      render_table()
    })
  
  # Load map based on census variable input
  # TODO Change from direct input$variable to tail of multiselect vector
  observeEvent({
    input$entity_level
    input$variable
    input$state_name
    input$municipality_name
    input$locality_name
  }, {
    switch(
      input$entity_level,
      "State" = {
        # Load map for state
        if (input$state_name == "All") {
          data_filtered = state_data() %>%
            select(state_name, input$variable, geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        } else {
          data_filtered = state_data() %>%
            filter(state_name == input$state_name) %>%
            select(state_name, input$variable, geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
      },
      "Municipality" = {
        # Load map for municipality
        if (input$state_name == "All") {
          data_filtered = muni_data() %>%
            select(state_name,
                   municipality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
        else if (input$municipality_name == "All") {
          data_filtered = muni_data() %>%
            filter(state_name == input$state_name) %>%
            select(state_name,
                   municipality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        } else {
          data_filtered = muni_data() %>%
            filter(
              state_name == input$state_name,
              municipality_name == input$municipality_name
            ) %>%
            select(state_name,
                   municipality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
      },
      "Locality" = {
        if (input$state_name == "All") {
          data_filtered = locality_data() %>%
            select(state_name,
                   locality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
        else if (input$municipality_name == "All") {
          data_filtered = locality_data() %>%
            filter(state_name == input$state_name) %>%
            select(state_name,
                   locality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        } else {
          data_filtered = locality_data() %>%
            filter(state_name == input$state_name,
                   locality_name == input$locality_name) %>%
            select(state_name,
                   locality_name,
                   input$variable,
                   geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
      },
      "AGEB" = {
        if (req(input$state_name != "All")) {
          if (input$locality_name != "All") {
            data_filtered <-  ageb_data() %>%
              select(state_name,
                     municipality_name,
                     input$variable,
                     geometry = gfw_geojson)
          } else if (req(input$municipality_name != "All")) {
            data_filtered <-  ageb_data() %>%
              select(state_name,
                     municipality_name,
                     input$variable,
                     geometry = gfw_geojson)
          }
        }
        geodata_filtered = geojson_sf(data_filtered[['geometry']])
      },
      "Block" = {
        req(input$state_name != "All")
        if (req(input$locality_name != "All")) {
          data_filtered = block_data() %>%
            select(locality_name, input$variable, geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
        else if (req(input$municipality_name != "All")) {
          data_filtered = block_data() %>%
            select(municipality_name, input$variable, geometry = gfw_geojson)
          geodata_filtered = geojson_sf(data_filtered[['geometry']])
        }
      }
    )
    
    # map
    output$census_map <- renderLeaflet({
      leaflet(geodata_filtered) %>%
        addTiles() %>%
        # addPolygons(data = data_filtered) %>%
        fitBounds(
          ~ as.numeric(st_bbox(geodata_filtered)[1]),
          ~ as.numeric(st_bbox(geodata_filtered)[2]),
          ~ as.numeric(st_bbox(geodata_filtered)[3]),
          ~ as.numeric(st_bbox(geodata_filtered)[4])
        )
    })
    
    
    
    census_variable_values = data_filtered %>%
      as.data.frame() %>%
      pull(input$variable)
    
    # define pal
    pal_census <- colorNumeric("RdYlBu",
                               census_variable_values,
                               na.color = "transparent",
                               reverse = TRUE)
    # define labels information
    labels_census <-
      sprintf(
        "<strong>%s</strong> %s <br/><strong>%s:</strong> %s <br/><strong>%s:</strong> %s<br/><strong>%s:</strong> %s",
        "State",
        input$state_name,
        "Census variable",
        input$variable,
        # "Census variable", selected_variable,
        "Value",
        census_variable_values,
        "Level",
        input$entity_level
      ) %>%
      lapply(htmltools::HTML)
    
    # plot map ----
    leafletProxy(mapId = "census_map", data = geodata_filtered)  %>%
      clearControls() %>%
      clearShapes() %>%
      # polygons ----
    addPolygons(
      data = geodata_filtered,
      group = "census-var",
      fillColor = ~ pal_census(census_variable_values),
      weight = 1,
      opacity = 1,
      color = "grey",
      fillOpacity = 0.9,
      label = labels_census,
      highlightOptions = highlightOptions(
        color = "black",
        weight = 2,
        bringToFront = FALSE
      ),
      labelOptions = labelOptions(
        style = list("font-weight" = "normal", padding = "3px 6px"),
        textsize = "15px",
        direction = "auto"
      )
    ) %>%
      # legend ----
    addLegend(
      pal = pal_census,
      values = census_variable_values,
      opacity = 0.9,
      # title = input$variable,
      title = input$variable,
      group = "census-var",
      position = "topright",
      labFormat = labelFormat(suffix = "")
    ) %>%
      # Layers control ----
    addLayersControl(overlayGroups = c("census-var"),
                     options = layersControlOptions(collapsed = FALSE)) %>%
      #hideGroup(c("Administrative boundaries")) %>%
      addFullscreenControl()
    
    
    # Download geospatial data
    geo_data = st_sf(data.frame(data_filtered, geom = geodata_filtered))
    
    output$downloadGeoData <- downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".geojson", sep = "")
      },
      content = function(file) {
        st_write(geo_data, file, driver = "GeoJSON")
      }
    )
  })
  
  # Populate municipality names based on state selection
  observeEvent({
    req(input$entity_level == "Municipality")
    input$state_name
  },
  {
    if (input$state_name != "All") {
      updateSelectizeInput(
        session,
        "municipality_name",
        choices = c("All", unique(muni_data()[muni_data()$state_name ==
                                                input$state_name, "municipality_name"])),
        selected = "All"
      )
    } else {
      (input$state_name == "All")
      updateSelectizeInput(
        session,
        "municipality_name",
        choices = c("All", unique(muni_data()$municipality_name)),
        selected = "All"
      )
    }
  })
  
  # Populate locality names based on state selection
  observeEvent({
    req(
      input$entity_level == "Locality" |
        input$entity_level == "AGEB" | input$entity_level == "Block"
    )
    input$state_name
    input$municipality_name
  },
  {
    # Filtered by state
    if (input$state_name != "All" && input$municipality_name == "All") {
      updateSelectizeInput(
        session,
        "locality_name",
        choices = c("All", unique(locality_data()[locality_data()$state_name ==
                                                    input$state_name, "locality_name"])),
        selected = "All"
      )
    } else if (input$state_name != "All" && input$municipality_name != "All") {
      updateSelectizeInput(session, "locality_name",
                           choices = c("All", unique(locality_data()[locality_data()$municaplity_name == input$municipality_name, "locality_name"])))
    } else {
      showNotification("Populating Locality dropdown")
      # All localities
      updateSelectizeInput(
        session,
        "locality_name",
        choices = c("All", unique(locality_data()$locality_name)),
        selected = "All"
      )
    }
    
  })
  
  observeEvent(req(input$state_name), {
    updateSelectizeInput(
      session,
      'municipality_name',
      choices = c("All", unique(muni_data()[muni_data()$state_name ==
                                              input$state_name, "municipality_name"])),
      selected = "All"
      
    )
    
  })
}

# Run the application
shinyApp(ui = ui, server = server)